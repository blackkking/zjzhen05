[TOC]

# Linux系统程序设计

## 计算机系统概论

操作系统利用一个或多个处理器的硬件资源，为系统用户提供一组服务，它还代表用户来管理辅助存储器和输入/输出(I/O)设备。因此，在开始分析操作系统之前掌握一些底层的计算机系统硬件知识是很重要的。

### 基本构成

从最顶层看，一台计算机由处理器，存储器和输入/输出部件组成，每一个部件有一个或多个模块。这些部件以某种方式互联，以实现计算机执行程序的主要功能。因此，计算机有四个主要的结构化部件：

- 处理器(processor)：控制计算机的操作，执行数据处理功能。当只有一个处理器是，它通常是指中央处理器(CPU)
- 主存储器(main memory): 存储数据和程序。此类存储器通常是易失性的，即当计算机关机时，它的内容不会丢失。主存储通常也称为实存储器(real memory)或主存储器(primary memory)
- 输入/输出模块(I/O modules): 在计算机和外部环境之间移动数据。外部环境由各种外部设备组成，包括二级存储器设备(如硬盘),通信设备和终端。
- 系统总线(System bus):为处理器，主存储器和输入/输出模块间提供通信的设施

### 处理器寄存器

处理器包括一组寄存器，它们提供一定的存储能力，比主存储器访问速度快，但比主存储器的容量小。处理器中的寄存器有两个功能

- 用户可见寄存器：优先使用这些寄存器，可以使机器语言或汇编语言的程序员减少对主存储器的访问次数。对高级语言而言，由优化编译器负责决定哪些变量应该分配给寄存器，哪些变量应该分配给主存储器，一些高级语言允许程序员建议编译器把哪些变量保存在寄存器中
- 控制和状态寄存器：用以控制处理器的操作，且主要被具有特权的操作系统历程使用，以控制程序的执行。


## 基本文件I/O

### 文件与文件访问基本概念

#### Linux文件分类

Linux文件是对大多数系统资源访问的接口。

- 普通文件(regular file)：用户可以看到的文件，有文本文件和二进制文件ls-l 第一个显示的字符是“-”
- 目录文件(directory),管理和组织系统的大量文件。"d"
- 设备文件。Linux把每一个I/O设备都看成一个文件."c" "b"
- 管道文件(named pipe),主要用于在进程传递数据。管道文件又称先进先出(FIFO)文件 "p"
- 套接字文件(socket).类似于管道文件.管道文件用于本地通信。而套接字允许网络上的通信 "s"
- 符号链接文件(stmbolic link),这个文件包含了另一个文件的陆建明。被链接的文件可以是任意文件和目录，可以链接不同文件系统的文件，"l"

#### 文件的相关最基本元素

- 目录结构。系统中的每一个目录都处于一定的目录结构当中。目录结构含有目录中所有目录的列表，每个目录项都含有一个文件名称和一个索引节点，借助于名称，应用程序可以访问目录项的内容，而索引节点提供了文件自身的信息。所以，目录只是将文件的名称和它的索引号结合在一起的一张表，目录中每一对文件名称和索引节点号，却可以有多个文件名与之对应。因此，在磁盘上的同一个文件可以通过不同的路径去访问它。
- 索引节点。目录结构包含文件名称和目录位置等信息，而索引节点本身并不包含这些信息，因此Linux允许使用多个文件名来引用磁盘上的同一块数据，多个文件名都可以访问同一个索引节点。
- 文件的数据。它的存储位置由索引节点指定，有这些特殊文件，比如管道及设备文件。在硬盘上不具有数据区域。而普通文件和目录都拥有数据区域。


#### 文件访问基本概念

​	Linux提供了丰富的文件访问接口，如我们用opendir()等函数后去目录结构信息。通过调用stat()可以从索引节点获得文件信息。通过open(),read()等等访问文件的数据。

​	Linux操作系统中各种类型的文件都采用统一的I/O方法来进行访问。从、因此，从磁盘中读取一个文件中的程序和从网络中读取数据的程序一样简单。

​	对文件执行I/O 操作，有两种基本方式：一种是系统调用的I/O方法，另一种是基于流的I/O方法。

​	系统调用的I/O方法提供了最基本的文件访问接口：open().close().write(),read()和lseek()等。基于流的I/O方法实际上是建立在系统调用的I/O方法基础上的C函数库，它基于系统调用方法的封装并增加了额外的功能。例如采用缓冲技术来提高程序的效率，输入解析以及格式化输出等。然而在处理设备，管道，网络套接字和其他特殊类型的文件的时候，必须使用系统调用I/O方法。

​	系统调用和基于流的区别:

​	1.基于流的文件函数名字都是以字母“f"开头

​	2.系统调用是更低一级的接口，调用需要更多编码的工作

​	3.系统调用直接处理文件描述符，流函数处理“FILE*”类型的文件句柄

​	4.基于流的I/O 方法是对系统调用方法的封装，流I/O 方法使用自动缓冲技术，程序性能会更高

​	5.基于流的方法支持格式化输出，类似于fprintf()这样的函数

​	6.基于流的方法替用户处理有关系统调用的细节，比如系统调用被信号中断的处理等等

​	基于流的方法会给我们带来极大的方便，但某些程序却不能使用流的I/O 方法。比如使用缓冲技术使得网络通信陷入困境，因为它会干扰网络通讯所使用的通信协议，考虑到这两种方法的不同，使用终端或者通过文件交换信息我们一般用流的I/O。而使用网络或管道通信时，通常采用系统调用的I/O方法

#### 文件访问的系统调用的API

```c
//文件的创建，打开和关闭
fd = open("/tmp/open_test",O_CREAT|O_WRONLY|O_TRUNC,0640);
fd = creat("/tmp/open_test",0640);
//原型
int open(const char *pathname, int flags); //失败返回-1
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
int close(int fd);
//保证数据写入磁盘等物理存储设备中
int fsync(int fd);
//文件的读写
ssize_t read(int fd,void *buf,size_t count);
ssize_t write(int fd, const void *buf, size_t count);
//fd:要进行对鞋的文件描述符 buf： 要写入文件内容或读出文件内容的内存地址 count: 要读写的字节数
//lseek()系统调用可以使文件指针移动到文件中的指定位置
off_t lseek(int fd,off_t offset,int whence);
/*fd 文件描述符 offset:移动的偏移量，单位的字节数 whence:文件指针移动偏移量的解释。有三个选项：
SEEK_SET:从文件头开始计算，文件指针移动到offset个字节位置
SEEK_CUR:从文件指针当前位置开始计算，向后移动offset个字节的位置
SEEK_END:文件指针移动到文件结尾
lseek()移动成功，返回为文件指针当前位置 失败返回-1*/
//access()用来判断文件是否有读写等权限
int access(const char *pathname,int mode);
R_OK是否有可读权限  W_OK写权限  X_OK执行  F_OK是否存在
//存在返回0 不存在返回-1

 //修改文件属性
 int fnctl(int fd,int cmd);
 int fnctl(int fd,int cmd,lont arg);
 int fnctl(int fd,int cmd,struct flock *lock);
/*复制一个文件描述符(cmd = F_DUPFD)。
获取/设置文件描述符标志(cmd = F_GETFD 或 cmd = F_SETFD)。
获取/设置文件状态标志(cmd = F_GETFL 或 cmd = F_SETFL)。 获取/设置文件锁(cmd = F_GETLK、 cmd = F_SETLK 或 cmd = F_SETLKW)。*/

```

#### 文件访问的C库函数

```c
//文件创建，打开和关闭
FILE *fopen(const char *path,const char* mode);
// w写 w+读写 r读 r+读写 a追加 a+清空再追加 成功返回文件句柄，失败返回NULL
int fclose(FILE *fp);
//按字符读文件
int fgetc(FILE* stream);
int getc(FILE* stream);
fgetc()用 unsigned char 的格式来读取一个字符并映射为一个 int 值，如果读取正确，返回读取的字符的 int 值；否则，当读取错误或遇到文件结束标志 EOF 时，返回 EOF， EOF在头文件的定义为-1.
//getc 是fgetc的宏定义别名
//按字符写文件
int fputc(int c,FILE* stream);
int putc(int c,FILE* stream);
第一个参数是要写入的字符，成功返回字符的值，失败赶回EOF
//按字符串读文件
char *fgets(char *s, int size, FILE *stream);
fgets()函数从文件中读入一行以“\0”或 EOF 结尾的字符串。 
第一个参数是存放读出来的字符串的地址，第二个参数指定了一次最多读取 n 个字符，第三个参数指定了文件句柄。fgets()函数将从文件偏移指针的当前位置依次读取字符存入字符串指针 s 中。函数读取字符直至 n-1 个字符或遇到换行符或文件结束标志 EOF 为止。
//成功返回s 失败返回NULL
//字符串写入文件
int fputs(const char *s, FILE *stream); 
//成功返回非负数，失败返回EOF

```

```c
//按数据块读写文件
对于非文本文件， 比如二进制文件等， 当需要一次读写一组数据的时候， 我们可以使用 fread()和 fwrite()函数来读写文件。
size_t fread(void *ptr, size_t size， size_t nmemb， FILE *stream);
size_t fwrite(const void *ptr, size_t size， size_t nmemb， FILE *stream);
第一个参数分别是要读写的数据的地址，第二个参数是数据块的大小，第三个参数是要读写的数据块的数目，第四个参数是文件句柄。
//当读写操作成功时，函数返回成功读写的数据块的数量。如果返回的数量小于第三个参数指定的读写数量时，表明发生了错误或者读文件遇到了文件结束符 EOF。这种情况下，fread()无法区分读数据时是出错还是遇到文件结束符，通常可以使用 feof()函数来判断是否读到了文件尾，或者用 ferror()函数来判断是否是读文件出错。

//格式化写入，成功写入返回字符数，错误返回负数
int fprintf(FILE *stream， const char *format， ...);
//格式化输出，成功写入返回字符数，错误返回负数
int fscanf(FILE *stream， const char *format， ...);

//文件的随机存取
int fseek(FILE *stream， long off'set， int whence);
whence：文件指针移动偏移量的解释，有三个选项：SEEK_END，SEEK_CUR，从当前偏移。SEEK_SET，从文件头开始移动
//告诉指针当前位置
long ftell(FILE *stream);
```

## 进程和线程

### 什么是进程

进程的标准定义是：“进程是一个具有独立功能的程序关于某个数据集合的一次可以并发执行的运行活动，是处于活动状态的计算机程序”。 

#### 进程的结构

Linux 是一个多处理操作系统。进程具有独立的权限与职责。如果系统中某个进程崩溃，

Linux 是一个多处理操作系统。进程具有独立的权限与职责。如果系统中某个进程崩溃，
它不会影响到其余的进程。每个进程运行在其各自的虚拟地址空间中， 进程之间可以通过由

Linux 是一个多处理操作系统。进程具有独立的权限与职责。如果系统中某个进程崩溃，它不会影响到其余的进程。每个进程运行在其各自的虚拟地址空间中， 进程之间可以通过由内核控制的机制相互通讯。 



