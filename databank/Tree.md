[TOC]

# 哈夫曼树及其应用

## 树和二叉树

### 树的概念与定义

#### 什么是树

树是n（n≥0）个结点的有限集合T。当n=0时，称为空树；当n>0时，该集合满足如下条件： 

- 其中必有一个称为根（root）的特定结点，它没有直接前驱，但有零个或多个直接后继。
- 其余n-1个结点可以划分成m（m≥0）个互不相交的有限集T1，T2，T3，…，Tm，其中Ti又是一棵树，称为根root的子树。每棵子树的根结点有且仅有一个直接前驱，但有零个或多个直接后继。

#### 树的基本术语：

- 结点：包含一个数据元素及若干指向其它结点的分支信息。
- 结点的度：一个结点的子树个数称为此结点的度
- 叶结点：度为0的结点，即无后继的结点，也叫终端结点
- 分支结点：度不为0的结点
- 孩子结点：一个结点的直接后继结点是该结点的孩子结点
- 双亲结点：一个结点的直接前驱称为该结点的双亲结点
- 兄弟结点：同一双亲结点的孩子结点之间互称兄弟结点
- 祖先结点：一个结点的祖先结点是指从根结点到该结点的路径上的所有结点
- 堂兄弟结点：其双亲在同一层的结点
- 子孙结点：一个结点的直接后继和间接后继
- 数的度：树种所有结点的度的最大值
- 结点的层次：从根结点开始定义，根结点的层次为1，根的直接后继的层次为2
- 树的高度(深度)：树中所有结点的层次的最大值
- 有序树：在树T中，如果各子树Ti之间是有先后次序的，则叫有序树
- 森林：m(m>=0)棵树互不相交的树的集合

#### 数的抽象数据类型定义

- 数据对象D：一个集合，该集合中所有元素具有相同的特性
- 数据关系R：若D为空集，则为空树。若D中仅含有一个数据元素，则R为空集，否则R={H},H是如下的的二元关系
- 在D中存在唯一的称为根的数据元素root,它在关系H下没有前驱
- 除了root以外，D中每个结点在关系H下都有且仅有一个前驱

#### 树的基本操作

```c
/*InitTree（Tree）： 将Tree初始化为一棵空树。 
DestoryTree（Tree）： 销毁树Tree。 
CreateTree（Tree）： 创建树Tree。 
TreeEmpty（Tree）： 若Tree为空，则返回TRUE，否则返回FALSE。 
Root（Tree）： 返回树Tree的根。 
Parent（Tree，x）： 树Tree存在，x是Tree中的某个结点。若x为非根结点，则返它的双亲，否则返回“空”。 
FirstChild（Tree，x）： 树Tree存在，x是Tree中的某个结点。若x为非叶子结点，则返回它的第一个孩子结点，否则返回“空”。 
NextSibling（Tree，x）： 树Tree存在，x是Tree中的某个结点。若x不是其双亲的最后一个孩子结点，则返回x后面的下一个兄弟结点，否则返回“空”。 
InsertChild（Tree，p，Child）： 树Tree存在，p指向Tree中某个结点，非空树Child与Tree不相交。将Child插入Tree中，做p所指向结点的子树。 
DeleteChild（Tree，p，i）： 树Tree存在，p指向Tree中某个结点，1≤i≤d，d为p所指向结点的度。删除Tree中p所指向结点的第i棵子树。 
TraverseTree（Tree，Visit（））： 树Tree存在，Visit（）是对结点进行访问的函数。按照某种次序对树Tree的每个结点调用Visit（）函数访问一次且最多一次。若Visit（）失败，则操作失败。*/ 

```



### 二叉树

#### 什么是二叉树

我们把满足以下两个条件的树型结构叫做二叉树（Binary Tree）： 

- 每个结点的度都不大于2；


- 每个结点的孩子结点次序不能任意颠倒。

#### 二叉树的基本操作

```c
/*
Initiate（bt）：将bt初始化为空二叉树。 
Create(bt)：创建一棵非空二叉树bt。 
Destory（bt）： 销毁二叉树bt。 
Empty（bt）： 若bt为空，则返回TRUE，否则返回FALSE。 
Root(bt)： 求二叉树bt的根结点。若bt为空二叉树，则函数返回“空”。 
Parent（bt，x）：求双亲函数。求二叉树bt中结点x的双亲结点。若结点x是二叉树的根结点或二叉树bt中无结点x，则返回“空”。 
LeftChild（bt，x）：求左孩子。若结点x为叶子结点或x不在bt中，则返回“空”。RightChild（bt，x）：求右孩子。若结点x为叶子结点或x不在bt中，则返回“空”。Traverse（bt）: 遍历操作。按某个次序依次访问二叉树中每个结点一次且仅一次。Clear（bt）：清除操作。将二叉树bt置为空树。 

*/
```

#### 二叉树的性质

- 在二叉树的第i层上至多有2i-1个结点(i≥1)。 
- 深度为k的二叉树至多有2k-1个结点（k≥1）
- 对任意一棵二叉树T，若终端结点数为n0，而其度数为2的结点数为n2，则n0= n2+1 。
- 具有n个结点的完全二叉树的深度为小于㏒2n+1的最大整数。 
- 对于具有n个结点的完全二叉树，如果按照从上到下和从左到右的顺序对二叉树中的所有结点从1开始顺序编号，则对于任意的序号为i的结点有：
  - 若i = 1, 则 i 无双亲结点，若i >1, 则 i 的双亲结点为小于i /2的最大整数
  - 若2*i > n, 则 i 无左孩子，若2*i≤n, 则 i 结点的左孩子结点为2*i
  - 若 2*i+1 > n ,则i 无右孩子，若 2*i+1≤n, 则i的右孩子结点为2* i+1

#### 两种特殊的二叉树

- 满二叉树(Full Binary Tree) ：深度为k且有2k-1个结点的二叉树。在满二叉树中，每层结点都是满的，即每层结点都具有最大结点数。
- 完全二叉树：若设二叉树的高度为h，则共有h层。除第 h 层外，其它各层 (0  h-1) 的结点数都达到最大个数，第 h 层从右向左连续缺若干结点，这就是完全二叉树。

#### 二叉树的存储结构

二叉树的结构是非线性的，每一结点最多可有两个后继。二叉树的存储结构有两种：顺序存储结构和链式存储结构。

对于一般的二叉树，我们必须按照完全二叉树的形式来存储，就会造成空间的浪费。单支树就是一个极端情况。

```c
//二叉树的二叉链表结点的结构用C语言描述为 ： 
typedef struct Node
{
	DataType data;
  	struct Node *LChild;
  	struct Node *RChild;
}BiTNode,*BiTree;
//有时，为了找到父结点，可以增加一个Parent域，Parent域指向该结点的父结点
```

若一个二叉树含有n个结点，则它的二叉链表中必含有2n个指针域，其中必有n＋1个空的链域。

### 二叉树的遍历与线索化

二叉树的遍历：指按一定规律对二叉树中的每个结点进行访问且仅访问一次。 

用L、D、R分别表示遍历左子树、访问根结点、遍历右子树，那么对二叉树的遍历顺序就可以有：

- 访问根，遍历左子树，遍历右子树(记做DLR)。
- 访问根，遍历右子树，遍历左子树(记做DRL)。
- 遍历左子树，访问根，遍历右子树(记做LDR)。
- 遍历左子树，遍历右子树，访问根 (记做LRD)。
- 遍历右子树，访问根，遍历左子树 (记做RDL)。
- 遍历右子树，遍历左子树，访问根 (记做RLD)。

在以上六种遍历方式中，如果我们规定按先左后右的顺序，那么就只剩有DLR、LDR  和LRD三种。根据对根的访问先后顺序不同，分别称DLR为先序遍历或先根遍历；LDR为中序遍历（对称遍历）；LRD为后序遍历。

#### 三种遍历方法的递归定义

- 先序遍历（DLR）操作过程：若二叉树为空，则空操作，否则依次执行如下操作：（1）访问根结点；（2）按先序遍历左子树；（3）按先序遍历右子树。
- 中序遍历（LDR）操作过程：若二叉树为空，则空操作，否则依次执行如下操作：（1）按中序遍历左子树；（2）访问根结点；（3）按中序遍历右子树。
- 后序遍历（LRD）操作过程：若二叉树为空，则空操作，否则依次执行如下操作：（1）按后序遍历左子树；（2）按后序遍历右子树；（3）访问根结点。

#### 以二叉链表作为存储结构，讨论二叉树的遍历算法

```c
//先序遍历
void PreOrder(BiTree root)
//先序遍历二叉树, root为指向二叉树(或某一子树)根结点的指针
{
  if(root!=NULL)
  {
  	Visit(root->data); 	//访问根结点
    PreOrder(root->LChild); //先序遍历左子树
    PreOrder(root->RChild); //先序遍历右子树
  }  
}

//中序遍历
void  InOrder(BiTree root)  
/*中序遍历二叉树, root为指向二叉树(或某一子树)根结点的指针*/
{	
  	if (root!=NULL)
	{
	    InOrder(root ->LChild);   /*中序遍历左子树*/
	    Visit(root ->data);        /*访问根结点*/
	    InOrder(root ->RChild);   /*中序遍历右子树*/
	}
} 

//后序遍历
void  PostOrder(BiTree root)  
/* 后序遍历二叉树，root为指向二叉树(或某一子树)根结点的指针*/
{	
  	if(root!=NULL)
	{
	    PostOrder(root ->LChild); /*后序遍历左子树*/
	    PostOrder(root ->RChild); /*后序遍历右子树*/
	    Visit(root ->data);       /*访问根结点*/
	}
} 

```

#### 基于栈的递归消除

在大量复杂的情况下，递归的问题无法直接转换成循环，需要采用工作栈消除递归。工作栈提供一种控制结构，当递归算法进层时需要将信息保留；当递归算法出层时需要从栈区退出信息。

```c
//中序遍历二叉树的非递归算法（调用栈操作的函数）
//首先应用递归进层的三件事与递归退层的三件事的原则,直接先给出中序遍历二叉树的非递归算法基本实现思路。 
void InOrder(BiTree root) //中序遍历二叉树的非递归算法 
{
  InitStack(&S);p=root;
  while(p!=NULL||!IsEmpty(S))
  {
  	if(p!=NULL) //根指针进栈，遍历左子树
    {
  		Push(&S,p);
      	p=p->LChild;
	}
    else
    { //根指针退栈，访问根结点，遍历右子树
      Pop(&S,&p);
      Visit(p->data);
      p=p->RChild;
	}
  }
}
```

### 树、森林和二叉树的关系



### 哈夫曼树及其应用



### 树的计数   



