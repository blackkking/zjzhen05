/*小青蛙有一天不小心落入了一个地下迷宫,小青蛙希望用自己仅剩的体力值P跳出这个地下迷宫。
为了让问题简单,假设这是一个n*m的格子迷宫,迷宫每个位置为0或者1,0代表这个位置有障碍物,
小青蛙达到不了这个位置;1代表小青蛙可以达到的位置。小青蛙初始在(0,0)位置,地下迷宫的出
口在(0,m-1)(保证这两个位置都是1,并且保证一定有起点到终点可达的路径),小青蛙在迷宫中水
平移动一个单位距离需要消耗1点体力值,向上爬一个单位距离需要消耗3个单位的体力值,向下移
动不消耗体力值,当小青蛙的体力值等于0的时候还没有到达出口,小青蛙将无法逃离迷宫。现在
需要你帮助小青蛙计算出能否用仅剩的体力值跳出迷宫(即达到(0,m-1)位置)。
输入描述:
输入包括n+1行:

第一行为三个整数n,m(3 <= m,n <= 10),P(1 <= P <= 100)

接下来的n行:

每行m个0或者1,以空格分隔
输出描述:
如果能逃离迷宫,则输出一行体力消耗最小的路径,输出格式见样例所示;如果不能逃离迷宫,则输出"Can not escape!"。
测试数据保证答案唯一
示例1
输入
4 4 10
1 0 0 1
1 1 0 1
0 1 1 1
0 0 1 1
输出
[0,0],[1,0],[1,1],[2,1],[2,2],[2,3],[1,3],[0,3]

*/

bool bIsCouldOut(int P,int n,int m)
{
	
}


/* 一个数组有N个元素，求连续子数组的最大和。例如：[-1,2,1],和最大的连续子数组为[2,1],其和为3
输入：两行 第一行为一个整数n(1<=n<=100000),表示一共有n个元素
第二行为n个数，即每个元素，每个整数都在32位int范围内。以空格分隔。
输出：所有连续子数组中和最大的值
example：输入 3 -1 2 1 输出： 3 */

int sumMaxArrary(int count,int* iArray)
{
	int rtmax,sum,max,i,j,k;
	int *sumArray,*totalArray;
	for(i=1;i<=count;i++)	//子数组长度
	{
		for(j=0;j<count-i;j++)			//子数组第一个元素
		{
			for(k=0;k<i;k++)
			{
				sum += iArray[j+k];
			}
			sumArray[j]=sum;
			if(j==0)
			{
				max=sumArray[j];
			}else{
				if(sumArray[j]>max)
					max=sumArray[j];
			}
		}
		totalArray[i-1]=max;
		if(i==1)
		{
			rtmax=totalArray[i-1];
		}else{
			if(totalArray[i-1]>rtmax)
				rtmax=totalArray[i-1];
		}
	}
	return rtmax;
	
}

/*洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，
从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，
左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始
洗牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数
第二张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来
就可以了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；
右手拿着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，
我们按照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，
请输出这副牌洗牌k次之后从上往下的序列。
输入描述：第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，
第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。
表示原始牌组从上到下的序列。
输出描述：对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。
示例1
输入
3
3 1
1 2 3 4 5 6
3 2
1 2 3 4 5 6
2 2
1 1 1 1
输出
1 4 2 5 3 6
1 5 4 3 2 6
1 1 1 1

































/*现在我们有一个int数组，请你找出数组中每个元素的下一个比它大的元素。
给定一个int数组A及数组的大小n，请返回一个int数组，代表每个元素比他大的下一个元素
,若不存在则为-1。保证数组中元素均为正整数。
[11,13,10,5,12,21,3],7
返回：[13,21,12,12,21,-1,-1]*/

void rtBigerArray(int n,int* A,int* iRtArray)
{
	int i,j,count=0;
	for(i=0;i<n;i++)
	{
		for(j=i+1;j<n;j++)
		{
			if(A[j]>A[i])
			{
				count++;
				if(count==1)
				iRtArray[i]=A[j];
			}else{
				iRtArray[i]=-1;
			}
			count=0;
		}
	}
	
}

/*洗牌在生活中十分常见，现在需要写一个程序模拟洗牌的过程。 现在需要洗2n张牌，
从上到下依次是第1张，第2张，第3张一直到第2n张。首先，我们把这2n张牌分成两堆，
左手拿着第1张到第n张（上半堆），右手拿着第n+1张到第2n张（下半堆）。接着就开始洗
牌的过程，先放下右手的最后一张牌，再放下左手的最后一张牌，接着放下右手的倒数第二
张牌，再放下左手的倒数第二张牌，直到最后放下左手的第一张牌。接着把牌合并起来就可以
了。 例如有6张牌，最开始牌的序列是1,2,3,4,5,6。首先分成两组，左手拿着1,2,3；右手拿
着4,5,6。在洗牌过程中按顺序放下了6,3,5,2,4,1。把这六张牌再次合成一组牌之后，我们按
照从上往下的顺序看这组牌，就变成了序列1,4,2,5,3,6。 现在给出一个原始牌组，请输出这
副牌洗牌k次之后从上往下的序列。
输入描述:
第一行一个数T(T ≤ 100)，表示数据组数。对于每组数据，第一行两个数n,k(1 ≤ n,k ≤ 100)，接下来一行有2n个数a1,a2,...,a2n(1 ≤ ai ≤ 1000000000)。表示原始牌组从上到下的序列。
输出描述:
对于每组数据，输出一行，最终的序列。数字之间用空格隔开，不要在行末输出多余的空格。
示例1
输入
3
3 1
1 2 3 4 5 6
3 2
1 2 3 4 5 6
2 2
1 1 1 1
输出
1 4 2 5 3 6
1 5 4 3 2 6
1 1 1 1
*/












